{
  "hash": "2856d40101c2c703f9650c6ba9e19c80",
  "result": {
    "engine": "knitr",
    "markdown": "---\nexecute:\n  echo: true\n---\n\n# Data analysis in R {#sec-ch-computing}\n\n\n\n\n\n## Learning goals {.unnumbered}\n\n-   Wrangle and manipulate data using **dplyr**\n-   Create visualizations using **ggplot2**\n-   Customize **ggplot2** visualizations\n-   Create reproducible documents using Quarto\n\n## Data: Palmer penguins {#sec-penguins-intro}\n\nIn this chapter, explore data about penguins collected at the Palmer Station in Antarctica. The data were collected 2007 - 2009 by Dr. Kristen Gorman with the Palmer Station Long Term Ecological Research Program. The data are in the `penguins` data frame in the **palmerpenguins** R package [@palmerpenguins].\n\nWe will use the following variables:\n\n-   `species`: Penguins species (Adelie, Chinstrap, Gentoo)\n\n-   `island:` Island in Palmer Archipelago (Biscoe, Dream, Torgersen)\n\n-   `bill_length_mm`: Bill length in millimeters\n\n-   `flipper_length_mm` : Flipper length in millimeters\n\n-   `sex` : Penguins sex (female, male)\n\n-   `year` : Study year (2007, 2008, 2009)\n\nSee the [@palmerpenguins] for the full code book.\n\n## Installation\n\n### Installing R and RStudio\n\nWe will use the statistical analysis software R. Go to [https://cran.rstudio.com](https://cran.rstudio.com/) to download and install R. R version 4.5.0 was used for the computing in this book. We use R through an integrated user environment (IDE). The IDE is a user-friendly interface with additional features that make it easier to use the underlying software. @moderndive describes it this way, \"R is like a car’s engine while \\[the IDE\\] is like a car’s dashboard.\" <!--# do i need a page number?-->\n\nThere are two widely used IDEs for R offered by the open-source data science company Posit: RStudio and Positron. At this point, RStudio is the most commonly used environment for R [@posit-downloads] and is widely used by R programmers in classes, academic research, and industry. Go to [https://posit.co/download/rstudio-desktop](https://posit.co/download/rstudio-desktop/) to download RStudio on a laptop or desktop computer. A cloud-based version is also available on Posit Cloud (<https://posit.cloud/>). Positron is a new IDE designed specifically for a data science workflow. It has more advanced data exploration and AI-assistance capabilities compared to RStudio. Go to [https://positron.posit.co](https://positron.posit.co/) to download Positron[^02-review-r-1].\n\n[^02-review-r-1]: At this point, Positron is fairly new, so it has not been widely adopted in the classroom. We anticipate that will change over time as more users move to Positron.\n\nOverall, the content in this chapter is the same when using RStudio and Positron, with the exception of a minor difference mentioned in @sec-quarto.\n\n### Installing R packages\n\nCoding in R is primarily done by calling functions that perform specific tasks. These functions are located in packages. There is a collection of \"base R\" functions that are automatically loaded in R. A list of packages for the most recent version of R is available at @R-base-package-index.\n\nEven with a lot of functionality built into R, we may want to utilize advanced or specialized functions that are available through R packages. There are two primary ways to install packages: from the Comprehensive R Archive Network (CRAN) or from GitHub repositories.\n\nCRAN is the official network for hosting R packages and documentation, and packages must undergo R a rigorous review and testing process to be hosted on CRAN. We use the code `install.packages(\"Package Name\")` to install packages from CRAN. For example, the code to install the **tidyverse** package is\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"tidyverse\")\n```\n:::\n\n\nPackages that are not available on CRAN are typically available through a GitHub repository created by the package developer. This is often the cases for new packages or in-development versions of existing packages. We use the code `remotes::install_github(\"Package repo\")` to install packages from GitHub. The code `remotes::` calls the **remotes** package [@remotes] that contains the `install_github` function.[^02-review-r-2]\n\n[^02-review-r-2]: Use `install.packages(\"remotes\")` if the **remotes** package is not installed.\n\n<!--# I think I'm ok without an example of installing from GitHub?-->\n\nPackages only need to be installed [**once**]{.underline} on a given computer or virtual machine; however, we can periodically update them as new versions are released. Once the package is installed, we use the `library()` function to load it into R. Though we only install packages once, we need to load packages each time we have a new instance of R.\n\n::: {.analysis_in_practice latex=\"\"}\nInstalling versus loading packages has been compared to the lights in the room. The light bulbs are installed once, but we still need to flip a switch to turn on the light each time we enter a room.\n\n<!--# citation for this-->\n:::\n\n## Tidyverse {#sec-tidyverse}\n\nThe **tidyverse** [@tidyverse] is an \"an opinionated collection of R packages designed for data science\" [@tidyverse-website]. Packages in the tidyverse have a common structure and syntax, making it more streamlined to utilize functions from multiple packages in a data analysis. As shown in the previous section, **tidyverse** is available on CRAN. We load **tidyverse** using the code below. From the output, we see the nine core packages that load as part of **tidyverse**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\nThis chapter focuses on **dplyr** [@dplyr], the package for data manipulation, and **ggplot2** [@ggplot2], the package data visualization. We will introduce other packages, as needed, in subsequent chapters. <!--# confirm if I actually do this--> See [https://tidyverse.org](https://tidyverse.orghttps://tidyverse.org/) for a full description of all the core **tidyverse** packages.\n\n### Tidy data {#sec-tidy-data}\n\nA central component of the tidyverse is the notion of \"tidy\" data. @wickham2014tidy defines **tidy data** as data sets that have the following characteristics:\n\n> 1.  Each variable forms a column.\n> 2.  Each observation forms a row.\n> 3.  Each type of observational unit forms a table.\n\nLet's take a look at the `penguins` data frame from the **palmerpenguins** package that was introduced in @sec-penguins-intro.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(palmerpenguins)\ndata(penguins)\n```\n:::\n\n\nThe first ten rows of `penguins` is shown in @tbl-penguins.\n\n\n::: {#tbl-penguins .cell tbl-cap='First 10 rows of `penguins` data'}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n6 Adelie  Torgersen           39.3          20.6               190        3650\n# i 4 more rows\n# i 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n\nLet's use the criteria above to evaluate whether this is a tidy data frame.\n\n1.  *Each variable forms a column.*\n    -   Yes, the variables are stored in individual columns. There are no instances of multiple variables stored in a single column or a single variable stored across multiple columns.\n2.  *Each observation forms a row.*\n    -   Yes, the information for one penguin (observation) is across a single row. There are no instances of multiple penguins represented on a single row or a single penguin represented across multiple rows.\n3.  *Each type of observational unit forms a table.*\n    -   Yes, the observational unit is the set of penguins included in the study. The data from these penguins makes up the data frame.\n\n**All the criteria are met, so `penguins` is a tidy data frame.**\n\nAll the data sets used in the book are tidy, so we can focus on regression analysis concepts and methods. In practice, we may need to \"tidy\" data before doing any analysis. @wickham2014tidy has recommendations for handling different issues that make data untidy.\n\nThe data sets in the tidyverse are stored as tibbles. **Tibbles** are like data frames in R with some differences in the underlying features. As @wickham2023r puts it, a tibble is a data frame that modifies \"some older behaviours to make life a little easier\". One nice feature of tibbles is that they show summary information about the data set overall and for each variable. For example, in @tbl-penguins we see there are 344 rows (observations) and 8 columns (variables). We also see the format of each column, e.g. `species` is stored as a `<fct>` (factor). We talk more about data formats in @sec-initial-check.\n\n### **The pipe**\n\nOne benefit of the **tidyverse** syntax is its readability. Though it can be more verbose than other coding styles, its naming convention and structure makes it easy <!--# better word here--> to read and understand. A key part of the readability is due to the pipe. The **pipe**, coded as `|>`, is used to pass data from one function to the next. If we think of reading code aloud in English, we say \"and then\" when we see a pipe [@cetinkaya2021educator].\n\nFor example, let's suppose we write code to describe the steps to make a ham and cheese sandwich. <!--# idea from me, code inspiration from chat gpt-->\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbread_slice |>\n  add_layer(ingredient = \"ham\") |> \n  add_layer(ingredient = \"cheese\") |> \n  add_bread_slice()\n```\n:::\n\n\nWe would read this aloud in English as the following:\n\n> Start with a bread slice,\n>\n> *and then add* a layer of ham\n>\n> *and then* add a layer of cheese,\n>\n> *and then add another bread slice.*\n\n<!--# does layer make sense here?-->\n\nA series of functions joined by pipes, like the sandwich example above, is called a **pipeline**. We will see pipelines throughout the next section as we introduce data manipulation with **dplyr.**\n\n## Data manipulation with dplyr\n\nThe **dplyr** package is **tidyverse**'s primary package for data wrangling and manipulation. We often use functions from **dplyr** for analysis steps such as data exploration ([@sec-ch-eda]), evaluating model conditions ([@sec-ch-slr-conditions]), and applying variable transformations ([@sec-ch-transformations]).\n\nThe functions in **dplyr** perform one of the following tasks: manipulate the data by row, manipulate the data by column, or manipulate groups of rows. We will show key functions in each of these categories that are used frequently in the text. The full list of **dplyr** functions is available at the dplyr reference site [https://dplyr.tidyverse.org](https://dplyr.tidyverse.org/index.html).\n\n### Data manipulation by row\n\n#### `filter()` {.unnumbered}\n\nThe `filter` function is used to choose rows based on a set of criteria defined by the columns in the data. For example, we may use `filter()` to narrow the data to a specific subgroup of observations. The filtering criteria can be based on one variable or multiple variables. For example, let's filter the data such that we choose the rows for penguins in the Adelie species.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  filter(species == \"Adelie\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 152 x 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n6 Adelie  Torgersen           39.3          20.6               190        3650\n# i 146 more rows\n# i 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n\n::: {.yourturn latex=\"\"}\nHow many penguins are in the Adelie species?[^02-review-r-3]\n:::\n\n[^02-review-r-3]: There are 152 penguins in the Adelie species.\n\nWe can filter based on multiple variables by specifying \"and\" or \"or\" criteria. For example, let's filter the data so that we choose rows for penguins in the Adelie species [**and**]{.underline} from Dream island.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  filter(species == \"Adelie\" & island == \"Dream\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 56 x 8\n  species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <fct>   <fct>           <dbl>         <dbl>             <int>       <int>\n1 Adelie  Dream            39.5          16.7               178        3250\n2 Adelie  Dream            37.2          18.1               178        3900\n3 Adelie  Dream            39.5          17.8               188        3300\n4 Adelie  Dream            40.9          18.9               184        3900\n5 Adelie  Dream            36.4          17                 195        3325\n6 Adelie  Dream            39.2          21.1               196        4150\n# i 50 more rows\n# i 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n\nThere are 56 penguins from the Adelie species and Dream island. This is a smaller subset than in the previous example, because observations have to satisfy both criteria to be included in the resulting tibble.\n\nAlternatively, let's suppose we wish to filter the data such that we choose penguins who are from the Adelie species [**or**]{.underline} from Dream island.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  filter(species == \"Adelie\" | island == \"Dream\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 220 x 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n6 Adelie  Torgersen           39.3          20.6               190        3650\n# i 214 more rows\n# i 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n\nThere are 220 penguins in the resulting tibble. There are more penguins in this tibble than in the previous two, because penguins can meet one or both of the criteria to be included in the resulting tibble.\n\nLastly, we use `!` to define criteria in terms of excluding observations that take a certain value. For example, let's select the penguins in the Adelie species and are [**not**]{.underline} on Dream island.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  filter(species == \"Adelie\" & island != \"Dream\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 96 x 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n6 Adelie  Torgersen           39.3          20.6               190        3650\n# i 90 more rows\n# i 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n\n#### `arrange()` {.unnumbered}\n\nThe `arrange` function is used to sort the data based on the values in one or more columns. This can be useful as we explore the data to identify outlying observations with unusually high or unusually low values. In the code below, the observations are sorted in ascending order (smallest to largest) based on values of `bill_length_mm` .\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  arrange(bill_length_mm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 x 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n1 Adelie  Dream               32.1          15.5               188        3050\n2 Adelie  Dream               33.1          16.1               178        2900\n3 Adelie  Torgersen           33.5          19                 190        3600\n4 Adelie  Dream               34            17.1               185        3400\n5 Adelie  Torgersen           34.1          18.1               193        3475\n6 Adelie  Torgersen           34.4          18.4               184        3325\n# i 338 more rows\n# i 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n\nFrom the first few observations, we see the values of `bill_length_mm` increase as we move down the list of observations. Now we can more easily see the smallest `bill_length_mm` in the data, 32.1 mm. Including the `desc` argument in the `arrange` function sorts the data in descending order (largest to smallest). The code below sorts the observations in descending order by `bill_length_mm`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  arrange(desc(bill_length_mm))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 x 8\n  species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <fct>     <fct>           <dbl>         <dbl>             <int>       <int>\n1 Gentoo    Biscoe           59.6          17                 230        6050\n2 Chinstrap Dream            58            17.8               181        3700\n3 Gentoo    Biscoe           55.9          17                 228        5600\n4 Chinstrap Dream            55.8          19.8               207        4000\n5 Gentoo    Biscoe           55.1          16                 230        5850\n6 Gentoo    Biscoe           54.3          15.7               231        5650\n# i 338 more rows\n# i 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n\nThe largest bill length in the data set is 59.6 mm.\n\n::: {.analysis_in_practice latex=\"\"}\nThese examples illustrate a feature of **tidyverse** pipelines. **Pipeline** always start with a tibble (`penguins` in these examples) and produce a tibble by default. We can extract a vector of values using `pull()` at the end of pipeline.\n\n<br>\n\nFor example, the code below extracts a vector of bill lengths sorted in ascending order.[^02-review-r-4]\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  arrange(bill_length_mm) |>\n  pull(bill_length_mm)\n```\n:::\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 32.1 33.1 33.5 34.0 34.1 34.4 34.5 34.6 34.6 35.0\n```\n\n\n:::\n:::\n\n:::\n\n[^02-review-r-4]: Only the first 10 observations are displayed.\n\n## Data manipulation by column\n\n#### `select()` {.unnumbered}\n\nThe `select` function narrows the data by choosing specific columns. We use this function when we want to retain or display only certain columns. For example, let's create a new tibble that only contains the columns `bill_length_mm` and `flipper_length_mm`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  select(bill_length_mm, flipper_length_mm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 x 2\n  bill_length_mm flipper_length_mm\n           <dbl>             <int>\n1           39.1               181\n2           39.5               186\n3           40.3               195\n4           NA                  NA\n5           36.7               193\n6           39.3               190\n# i 338 more rows\n```\n\n\n:::\n:::\n\n\nNote that the number of rows remains unchanged from the original data.\n\nWe may also exclude columns by using `-` in front of the column name. For example, in the code below we create a new tibble that excludes the column `species`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  select(-species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 x 7\n  island  bill_length_mm bill_depth_mm flipper_length_mm body_mass_g sex    year\n  <fct>            <dbl>         <dbl>             <int>       <int> <fct> <int>\n1 Torger~           39.1          18.7               181        3750 male   2007\n2 Torger~           39.5          17.4               186        3800 fema~  2007\n3 Torger~           40.3          18                 195        3250 fema~  2007\n4 Torger~           NA            NA                  NA          NA <NA>   2007\n5 Torger~           36.7          19.3               193        3450 fema~  2007\n6 Torger~           39.3          20.6               190        3650 male   2007\n# i 338 more rows\n```\n\n\n:::\n:::\n\n\n#### `mutate()` {.unnumbered}\n\nThe `mutate` function is used to create new columns or change the values in an existing column. We often use this in the analysis to create new variables from existing ones or to impute values for missing data.\n\nFor example, let's create a new variable called `dream` that takes value `1` if the penguin is from the Dream island and the value `0` otherwise (called an indicator variable).\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  mutate(dream = if_else(island == \"Dream\", 1, 0))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 x 9\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n6 Adelie  Torgersen           39.3          20.6               190        3650\n# i 338 more rows\n# i 3 more variables: sex <fct>, year <int>, dream <dbl>\n```\n\n\n:::\n:::\n\n\nAt the top of the tibble, we see the number of observations hasn't changed, but we now have an additional column in the data set. Below are the values of `island` and `dream` for ten randomly selected observations.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 2\n  island dream\n  <fct>  <dbl>\n1 Dream      1\n2 Biscoe     0\n3 Biscoe     0\n4 Biscoe     0\n5 Biscoe     0\n6 Dream      1\n# i 4 more rows\n```\n\n\n:::\n:::\n\n\nThis code uses the `if_else()` function, a useful function for applying \"if/else\" statements. The structure of the function is `if_else([Criteria], [Result if true], [Result if false])`.\n\nThe `mutate` function is also used to change the values in existing columns. Using the name of an existing column will overwrite the data in that column based on the output from `mutate()`. For example, there are 11 penguins in the data with missing values for `sex`. Therefore, we would like to input the value `Missing` if the data are missing and otherwise keep the original value of `sex`. The values of `sex` for ten randomly selected penguins are below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  mutate(sex = if_else(is.na(sex), \"Missing\", sex))\n```\n:::\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 1\n  sex    \n  <chr>  \n1 Missing\n2 male   \n3 female \n4 male   \n5 male   \n6 female \n# i 4 more rows\n```\n\n\n:::\n:::\n\n\nThe code above uses `is.na()`, a logical function that returns `TRUE` if the value is missing and `FALSE` otherwise.\n\n\n\n::: {.yourturn latex=\"\"}\nCreate a tibble that only includes penguins from `Biscoe` island. Arrange the rows in descending order of `bill_length_mm`. Display the columns `species` and `bill_length_mm`. What is the species and bill length for the first observation?[^02-review-r-5]\n:::\n\n[^02-review-r-5]: `penguins |> filter(island == \"Biscoe\") |> arrange(desc(bill_length_mm)) |> select(species, bill_length_mm)` . The species is Gentoo and the bill length is 59.6 mm.\n\n### Data manipulation by group\n\n#### `count()` {.unnumbered}\n\nThe `count` function is used to compute the number of observations that take each unique value in a column or combination of columns. We often use this in data analysis to produce frequency tables for categorical variables.\n\nFor example, the code below produces the number of observations from each island.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  count(island)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 2\n  island        n\n  <fct>     <int>\n1 Biscoe      168\n2 Dream       124\n3 Torgersen    52\n```\n\n\n:::\n:::\n\n\nWe may also compute the number of observations that take each combination of values for two or more variables. The code below produces the number of observations that take each combination of `island` and `species`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  count(island, species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 3\n  island    species       n\n  <fct>     <fct>     <int>\n1 Biscoe    Adelie       44\n2 Biscoe    Gentoo      124\n3 Dream     Adelie       56\n4 Dream     Chinstrap    68\n5 Torgersen Adelie       52\n```\n\n\n:::\n:::\n\n\nSome combinations of `island` and `species` are missing from the output. This means there are no observations in the data with that combination of values. For example, there are no penguins in the data who are from Biscoe island and the Chinstrap species. Include the argument `.drop = FALSE` to see all possible combinations of values, including those with zero observations in the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  count(island, species, .drop = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 9 x 3\n  island species       n\n  <fct>  <fct>     <int>\n1 Biscoe Adelie       44\n2 Biscoe Chinstrap     0\n3 Biscoe Gentoo      124\n4 Dream  Adelie       56\n5 Dream  Chinstrap    68\n6 Dream  Gentoo        0\n# i 3 more rows\n```\n\n\n:::\n:::\n\n\n#### `summarize()` {.unnumbered}\n\nThe `summarize`[^02-review-r-6] function computes summary statistics for columns in the data. See the `summarize()` reference page at [https://dplyr.tidyverse.org](https://dplyr.tidyverse.org/) for a list of commonly used summary statistics.\n\n[^02-review-r-6]: This function can also be spelled `summarise().`\n\nFor example, we want to compute the mean and standard deviation of `bill_length_mm`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  summarize(mean_bill_length = mean(bill_length_mm),\n            sd_bill_length = sd(bill_length_mm)) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 2\n  mean_bill_length sd_bill_length\n             <dbl>          <dbl>\n1               NA             NA\n```\n\n\n:::\n:::\n\n\nThis code did not return values but instead produced `NA`. By default, the functions for computing specific summary statistics, e.g., `mean()`, do not remove missing values (`NA)` from the computation. Thus, they are unable to compute summary statistics if there any values are missing in the column. We use the argument `na.rm = TRUE` to ignore missing values when computing summary statistics.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  summarize(mean_bill_length = mean(bill_length_mm, na.rm = TRUE), \n            sd_bill_length = sd(bill_length_mm, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 2\n  mean_bill_length sd_bill_length\n             <dbl>          <dbl>\n1             43.9           5.46\n```\n\n\n:::\n:::\n\n\nNote, this now means we have the mean and standard deviation of `bill_length_mm` among the rows that do not have missing observations, not all observations. Missing data is discussed in more detail in @sec-ch-eda. <!--# put specific section when written.-->\n\n#### `group_by()` {.unnumbered}\n\nThe last **dplyr** function we introduce here is `group_by()`. This function is used to perform calculations separately for subgroups of the data. This is often useful when we want to compare results between groups. For example, let's look at the mean and standard deviation of `bill_length_mm` by `species`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  group_by(species) |>\n  summarize(mean_bill_length = mean(bill_length_mm, na.rm = TRUE), \n            sd_bill_length = sd(bill_length_mm, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 3\n  species   mean_bill_length sd_bill_length\n  <fct>                <dbl>          <dbl>\n1 Adelie                38.8           2.66\n2 Chinstrap             48.8           3.34\n3 Gentoo                47.5           3.08\n```\n\n\n:::\n:::\n\n\nAll functions following `group_by()` in the pipeline will be performed separately for each subgroup. The `ungroup`function removes the grouping structure, so any functions following `ungroup()` are applied to all observations.\n\n::: {.yourturn latex=\"\"}\nUse `median()` to compute the median bill length separately for each combination of island and species. What is the median bill length for Adelie penguins on Dream island? [^02-review-r-7]\n:::\n\n[^02-review-r-7]: Code to compute median bill length by species and island: `penguins |> group_by(sex, species) |> summarize(median_bill_length = median(bill_length_mm, na.rm = TRUE))` . The median bill length for Adelie penguins on Dream island is 38.55 mm.\n\nThis section provided a short overview of the **dplyr** functions that are used frequently in this book. See Chapter 3 in *R for Data Science* [@wickham2023r] for more on data manipulation and Chapter 5 for more on tidy data.\n\n## Data visualizations using ggplot2\n\n**ggplot2** is the primary package for data visualizations in **tidyverse**. The code in **ggplot2** is designed to produce plots in layers, with each layer separated by `+`. This section is an overview of the package that largely follows the structure of Chapter 1 in *R for Data Science* [@wickham2023r]. We point readers there for a more detailed introduction to the package.\n\nThe general structure of code to create a visualization is as follows\n\n``` r\nggplot(data = [data set], aes(x = [x-var], y = [y-var])) + \n  geom_xx() + \n  other options \n```\n\n<!--# do i need to cite this code example?-->\n\nThe first part of the code establishes the base layer by specifying the tibble that will be used to make the visualization.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = penguins)\n```\n\n::: {.cell-output-display}\n![Base layer for a ggplot2 visualization](02-review-r_files/figure-pdf/fig-ggplot-base-1.png){#fig-ggplot-base width=85%}\n:::\n:::\n\n\nThe next part of the code is used to set the **aes**thetics that indicate how the variables are mapped onto features of the plot. It is defined in the `mapping =` argument inside the `aes()` function. Often times, we do not see the argument name `mapping =` in the code, but it is the second argument of `ggplot()`.\n\nLet's map the aesthetics such `bill_length_mm` is on the x-axis and `flipper_length_mm` is on the y-axis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = penguins, aes(x = bill_length_mm, y = flipper_length_mm))\n```\n\n::: {.cell-output-display}\n![Define variables for a ggplot2 visualization](02-review-r_files/figure-pdf/fig-ggplot-variables-1.png){#fig-ggplot-variables width=85%}\n:::\n:::\n\n\nNow that we have the foundation, the next layer of the code defines the type of plot to make. The plot types are defined using functions with the prefix `geom_`. Here we use `geom_point()` to make a scatterplot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = penguins, aes(x = bill_length_mm, y = flipper_length_mm)) + \n  geom_point()\n```\n\n::: {.cell-output-display}\n![Specify `geom` (plot type) for ggplot2 visualization](02-review-r_files/figure-pdf/fig-ggplot-geom-1.png){#fig-ggplot-geom width=85%}\n:::\n:::\n\n\n### Geoms\n\nWe will focus on the scatterplot for the majority of this section, but there are many other geoms available in **ggplot2**. Below are some of the geoms that will be used frequently throughout the book.\n\nThe first plots are a histogram and a density plot. Both are used to visualize the distribution of a single quantitative variable. The code and output produce the histogram and density plot for `bill_length_mm`.\n\n\n::: {#fig-histogram-density .cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\n# histogram\nggplot(data = penguins, aes(x = bill_length_mm)) + \n  geom_histogram()\n\n# density plot\nggplot(data = penguins, aes(x = bill_length_mm)) + \n  geom_density()\n```\n\n::: {.cell-output-display}\n![Histogram](02-review-r_files/figure-pdf/fig-histogram-density-1.png){#fig-histogram-density-1 width=85%}\n:::\n\n::: {.cell-output-display}\n![Density plot](02-review-r_files/figure-pdf/fig-histogram-density-2.png){#fig-histogram-density-2 width=85%}\n:::\n\nGeoms for single quantitative variable\n:::\n\n\nA common plot for the distribution of a single categorical variable is a bar graph. Below are the code and output of a bar graph of the distribution of `island`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = penguins, aes(x = island)) + \n  geom_bar()\n```\n\n::: {.cell-output-display}\n![Bar graph for single categorical variable](02-review-r_files/figure-pdf/fig-bar-graph-1.png){#fig-bar-graph width=85%}\n:::\n:::\n\n\nSide-by-side boxplots are used to visualize the relationship between a quantitative variable and a categorical variable. The code and output for a side-by-side boxplot of `bill_length_mm` versus `species` is below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = penguins, aes(x = species, y = bill_length_mm)) + \n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![Boxplot for quantitative and categorical variables](02-review-r_files/figure-pdf/fig-boxplot-1.png){#fig-boxplot width=85%}\n:::\n:::\n\n\nThese are a few of the many `geom`s available in **ggplot2**. A full list is available at [https://ggplot2.tidyverse.org](https://ggplot2.tidyverse.org/index.html).\n\n### Customizing plots {#sec-customize-plots}\n\nThere are a multitude of ways to customize plots in **ggplot2**. In this section, we will focus on customization that is used in the text and is useful for effective and clear data analysis and communication. These features are illustrated on the scatterplot of `bill_length_mm` versus `flipper_length_mm`, but they can be applied to any type of **ggplot2** visualization.\n\n#### Labels {.unnumbered}\n\nBy default, **ggplot2** labels the components of the plot using the variable names from `aes()`. If the variables have clear names, then these default labels are generally sufficient. When we are ready to communicate results (e.g,. through reports or presentations), the plot labels should be clear to the intended audience. This means using full words (or meaningful abbreviations), units when appropriate, and a title or caption.\n\nThe `labs()` function is used to create a new layer on the visualization with updated labels. The code below is used to change the labels on the x- and y-axes and add a title to the scatterplot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = penguins, aes(x = bill_length_mm, y = flipper_length_mm)) + \n  geom_point() +\n  labs(x = \"Bill length (in millimeters)\", \n       y = \"Flipper length (in millimeters)\", \n       title = \"Bill length versus Flipper length \")\n```\n\n::: {.cell-output-display}\n![Scatterplot with axis labels and title](02-review-r_files/figure-pdf/fig-ggplot-labels-1.png){#fig-ggplot-labels width=85%}\n:::\n:::\n\n\n#### Aesthetics\n\nThere are a variety of aesthetics, visual features, that can be customized in **ggplot2**. Some commonly used aesthetics include `color`, `shape`, `size`, `alpha` (transparency), `fill`, and `linetype`. The same aesthetics can be applied across the entire plot, or aesthetics can be applied based on values of a variable.\n\nWe often apply the same aesthetic across an entire plot to make it more visually appealing or easier to read. This type of aesthetic change does not add any additional information to the visualization.\n\nFor example, the code below changes the color of all points on the plot by adding the `color =` argument in `geom_point()`. The colors can be defined based on a list of over 600 colors[^02-review-r-8] or HTML hex color codes.\n\n[^02-review-r-8]: Type `colors()` in R to see the full list of built-in colors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = penguins, aes(x = bill_length_mm, y = flipper_length_mm)) + \n  geom_point(color = \"steelblue\") +\n  labs(x = \"Bill length (in millimeters)\", \n       y = \"Flipper length (in millimeters)\", \n       title = \"Bill length versus Flipper length \")\n```\n\n::: {.cell-output-display}\n![Color points on scatterplot](02-review-r_files/figure-pdf/fig-ggplot-color-points-1.png){#fig-ggplot-color-points width=85%}\n:::\n:::\n\n\nThe second way to apply aesthetics is to map them to specific variables. This adds makes the visualization engaging and adds additional information about the data. This is useful in data analysis when we want to make comparisons across subgroups of data.\n\nThe aesthetics are defined inside `aes()` to map them to a particular variable (similar to defining the variables that go on each axis). For example, the code below colors the points based on `species`. We also add a subtitle and update the `color` label in `labs()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = penguins, aes(x = bill_length_mm, y = flipper_length_mm, \n                            color = species)) + \n  geom_point() +\n  labs(x = \"Bill length (in millimeters)\", \n       y = \"Flipper length (in millimeters)\", \n       title = \"Bill length versus Flipper length\", \n       color = \"Species\",\n       subtitle = \"By species\")\n```\n\n::: {.cell-output-display}\n![Scatterplot with points colored by `species`](02-review-r_files/figure-pdf/fig-ggplot-color-by-species-1.png){#fig-ggplot-color-by-species width=85%}\n:::\n:::\n\n\nNow we are able to see the relationship between `bill_length_mm` and `flipper_length_mm` by species and make comparisons between species.\n\nWe can also map multiple aesthetics to variables. In the code below, the color of the points is based on `species` and the shape is based on `island`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = penguins, aes(x = bill_length_mm, y = flipper_length_mm, \n                            color = species, shape = island)) + \n  geom_point() +\n  labs(x = \"Bill length (in millimeters)\", \n       y = \"Flipper length (in millimeters)\", \n       title = \"Bill length versus Flipper length\", \n       color = \"Species\", \n       shape = \"Island\",\n       subtitle = \"By species and island\")\n```\n\n::: {.cell-output-display}\n![Scatterplot with color by `species` and shape by `island`](02-review-r_files/figure-pdf/fig-ggplot-color-shape-1.png){#fig-ggplot-color-shape width=85%}\n:::\n:::\n\n\n::: {.yourturn latex=\"\"}\nThe code below produces the plot of the `bill_length_mm` versus `species` in @fig-boxplot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = penguins, aes(x = species, y = bill_length_mm)) + \n  geom_boxplot()\n```\n:::\n\n\nDescribe how to update the code such that\n\n1.  all boxes are filled in using the color `cyan`.\n\n2.  the color of the boxes are filled in based on `species`.[^02-review-r-9]\n:::\n\n[^02-review-r-9]:\n    1.  Include `fill = \"cyan\"` in `geom_boxplot()` .\n    2.  Include `fill = species` in `aes().`\n\n### Faceting\n\nAnother way to view a visualization by subgroups is by **faceting**, creating a separate plot for each subgroup. The `facet_wrap` function is used to facet based on a single variable. In the code below, we modify the previous plot by faceting by `island` rather than changing the shape based on `island`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = penguins, aes(x = bill_length_mm, y = flipper_length_mm, \n                            color = species)) + \n  geom_point() +\n  labs(x = \"Bill length (in millimeters)\", \n       y = \"Flipper length (in millimeters)\",\n       title = \"Bill length versus Flipper length\", \n       color = \"Species\", \n       shape = \"Island\",\n       subtitle = \"Faceted by island\") + \n  facet_wrap(vars(island))\n```\n\n::: {.cell-output-display}\n![Scatterplot faceted by `island`](02-review-r_files/figure-pdf/fig-facet-wrap-1.png){#fig-facet-wrap width=85%}\n:::\n:::\n\n\nBecause there is a lot of overlap across islands, the faceted plot makes it easier to see the relationship within each island and identify which species are on each island.\n\nWe use `facet_grid()` to facet based on two variables, such that one variable defines the rows and the other defines the columns. In the code below, we now update the previous plot such that the rows are defined by `island` the columns are defined by `species`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = penguins, aes(x = bill_length_mm, y = flipper_length_mm, \n                            color = species)) + \n  geom_point() +\n  labs(x = \"Bill length (in millimeters)\", \n       y = \"Flipper length (in millimeters)\", \n       title = \"Bill length versus Flipper length\",\n       color = \"Species\",\n       subtitle = \"Faceted by island and species\") + \n  facet_grid(rows = vars(island),\n             cols = vars(species))\n```\n\n::: {.cell-output-display}\n![Scatterplot faceted by `island` and `species`](02-review-r_files/figure-pdf/fig-facet-grid-1.png){#fig-facet-grid width=85%}\n:::\n:::\n\n\nNote that `facet_grid()` creates a plot for every possible combination of the variables. The empty plots indicate combinations of `island` and `species` that do not exist in the data.\n\n::: {.yourturn latex=\"\"}\nRecreate the plot below of `flipper_length_mm` versus `species` faceted by `year`. [^02-review-r-10]\n:::\n\n[^02-review-r-10]: `ggplot(data = penguins, aes(x = species, y = flipper_length_mm, fill = species)) + geom_boxplot() + facet_wrap(vars(year))`\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Boxplot of `flipper_length_mm` versus `species` faceted by `year`](02-review-r_files/figure-pdf/fig-ggplot-yourturn-1.png){#fig-ggplot-yourturn width=85%}\n:::\n:::\n\n\n<!--# figure out how to get this in the callout box in latex-->\n\n### Color palettes {#sec-color-palettes}\n\nThus far, we have relied on the default color palette in **ggplot2** when we've mapped an aesthetic to color. We may wish to choose colors to align with a particular color scheme or those that are more accessible. The functions `scale_color_manual()` and `scale_fill_manual()` are used to \"manually\" define color palettes. We use `scale_color_manual()` to define a color palette that maps onto the `color` aesthetic and `scale_fill_manual()` to define a color palette that maps to the `fill` aesthetic.\n\nPackages such as **viridis** [@viridis] and **PNWColors** [@PNWColors] have pre-defined color palettes. Both packages are available on CRAN. In the code below, we apply the *Bay* color palette from the **PNWColors** package to @fig-ggplot-color-by-species, the scatterplot of `bill_length_mm` versus `flipper_length_mm` colored by `species`.\n\nThe argument `values = pnw_palette(\"Bay\", 3)` indicates that the colors are mapped to the *Bay* color palette using there colors (one for each species).\\\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(PNWColors)\n\nggplot(data = penguins, aes(x = bill_length_mm, y = flipper_length_mm, \n                            color = species)) + \n  geom_point() +\n  labs(x = \"Bill length (in millimeters)\", \n       y = \"Flipper length (in millimeters)\", \n       title = \"Bill length versus Flipper length\", \n       subtitle = \"By species\") +\n  scale_color_manual(values = pnw_palette(\"Bay\", 3))\n```\n\n::: {.cell-output-display}\n![Scatterplot with color palette from PNWColors](02-review-r_files/figure-pdf/fig-color-palette-1.png){#fig-color-palette width=85%}\n:::\n:::\n\n\nWe may also wish to create a color palette. For example, here we apply the palette `my_color_palette` that is defined using HTML hex codes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_color_palette <- c(\"#993399\", \"#2B8181\", \"#CB4F04\")\n\nggplot(data = penguins, aes(x = bill_length_mm, y = flipper_length_mm, \n                            color = species)) + \n  geom_point() +\n  labs(x = \"Bill length (in millimeters)\", \n       y = \"Flipper length (in millimeters)\", \n       title = \"Bill length versus Flipper length\", \n       subtitle = \"By species and island\") +\n  scale_color_manual(values = my_color_palette)\n```\n\n::: {.cell-output-display}\n![Scatterplot with user-define color palette](02-review-r_files/figure-pdf/fig-custom-color-palette-1.png){#fig-custom-color-palette width=85%}\n:::\n:::\n\n\nWhen choosing a color palette, it is important to consider the accessibility of the color choices, how they may be viewed by individuals with color-blindness <!--# is this correct-->, and how they appear in gray scale. There are multiple ways to check the accessibility of color palettes. The Color Palette Finder on the R Graph Gallery website (<https://r-graph-gallery.com/color-palette-finder>) is a tool for checking the accessibility of pre-defined color palettes. The **colorblindcheck** R package [@colorblindcheck] allows users to check the accessibility of pre-defined or custom color palettes.\n\n## Quarto {#sec-quarto}\n\nIn @sec-ch-intro we introduced reproducibility, a key component of data science in which analysis is conducted in such a way that another person (or ourselves months later) can produce the same results given the same code and data set.\n\nQuarto is \"an open-source scientific and technical publishing system\" [@quarto2025] developed by Posit for conducting reproducible data science. Quarto documents can produce many different types of formats <!--# other word here--> including PDFs, Word documents, websites, books, and others using a consistent syntax and document structure.[^02-review-r-11] Quarto is not automatically included in RStudio, so it must be installed. It can be downloaded from [https://quarto.org/docs/get-started](https://quarto.org/docs/get-started/). It is automatically installed in Positron.\n\n[^02-review-r-11]: In fact, this book was written using Quarto in RStudio!\n\n![Example Quarto document](images/02-quarto.jpg){#fig-quarto fig-align=\"center\" width=\"75%\"}\n\n@fig-quarto is an example of a Quarto (`.qmd`) document. All code, output, and narrative are in a single document, and the resulting output updates as changes are made to the document. This eliminates the need to copy and paste results from one document to another throughout the analysis, a process that is prone to error. Let's take a look at the parts of the Quarto document in @fig-quarto.\n\nThe **YAML** (\"Yet Another Markup Language\" or \"YAML Ain't Markup Language\") is considered the \"front matter\" of the document. This is where we include content for the heading, such as title, author, and date. This is also where we specify the format type and other global features to be applied for the entire document. The YAML in @fig-quarto shows global code chunk options applied so that the code is displayed when the document is rendered `echo: true` , but all additional warnings and messages are suppressed `warning: false` and `message: false` <!--# or is this messages?-->\n\nThe **code chunk** is where we put all code that is executed when the document is rendered. R code chunks[^02-review-r-12] can be added to the document by starting with ```` ```{r} ```` and ending with ```` ``` ````. They can also be added from the *Insert* menu in the tool bar of the visual editor. A variety of options can be applied to code chunks primarily to customize how they display code and results in the rendered document. Section 28.5 in *R for Data Science* [@wickham2023r] provides an extensive overview of code chunks and the set of options to customize them.\n\n[^02-review-r-12]: Quarto supports other coding languages such as Python and Julia.\n\nThe **narrative** is written in the white space of the document. The visual editor in RStudio and Positron makes formatting the narrative (e.g, making text bold or adding lists) similar to formatting in word processors such as Google Docs, Apple Pages, or Microsoft Word. The visual editor also makes it easy to add images and tables within the narrative.\n\n::: {#fig-quarto-render layout-ncol=\"2\"}\n![Rendering in RStudio](images/02-quarto-render-rstudio.jpg){#fig-quarto-render-1}\n\n![Rendering in Positron](images/02-quarto-render-positron.jpg){#fig-quarto-render-2}\n:::\n\nThroughout the analysis workflow, we regularly render the Quarto document to see the updated results and narrative. Documents are rendered by clicking the \"Render\" button in RStudio ([@fig-quarto-render-1]) and the \"Preview\" button in Positron ([@fig-quarto-render-2]). We also see the resulting PDFs in the Viewer pane of each IDE. When a document is rendered, all code and narrative are executed sequentially from beginning to end. Therefore, all necessary code must be in the Quarto document to render properly; code in the console is not executed when a document is rendered.\n\nThe assignments in the supplemental materials for this book are designed to be written in Quarto. See Chapter 28 in *R for Data Science* [@wickham2023r] and [quarto.org](https://quarto.org) for further reading and resources on Quarto.\n\n<!--# do i need github here? Yes!-->\n\n## Summary\n\nIn this chapter, we introduced data wrangling and data visualization using the **tidyverse** (specifically **dplyr** and **ggplot2** packages), focusing on code for the analysis tasks frequently used in this book. We also showed ways to customize plots for effective communication and accessibility, and we introduced Quarto for writing reproducible reports. There are many online resources about the **tidyverse** and Quarto. A few primary resources for additional reference and practice are the following: *R for Data Science* [@wickham2023r], [tidyverse.org](https://tidyverse.org), and [quarto.org](https://quarto.org).\n\nIn @sec-ch-eda, we utilize the computing from this chapter as we begin analyzing data in the exploratory data analysis.\n",
    "supporting": [
      "02-review-r_files/figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}